// varの問題点
//  ・グローバル変数を上書きしてしまう（標準API等にも影響する）
//  ・変数は巻き上げにより一番最初に宣言されるが、constやletと違い、エラーにならず、undefinedのまま実行されてしまう
//    ※varは変数の巻上が発生したタイミングでundefinedで変数を初期化している。一方、letやconstは変数の巻上が発生しても変数が評価されるまで変数は初期化されないため、初期化されていない変数を参照したとしてreference errorとなる

// 【型注釈】
// 変数宣言をするときに、その変数にどんな値が代入可能かを指定すること
// 【型推論】
// コンパイラが肩を自動で判別する機能

// 型推論はコンパイラに型を決めさせる、動的型付けは実行時に型が決まる
// また型推論は、コンパイルのタイミングで型が決定されるため、型をプログラマが書くかコンパイラが自動で決めるかの違いがあり、静的型付けの世界に閉じた話になる

// プリミティブ型
// boolean, number, string, undifined, null, symbol, bigint以外はすべてオブジェクト
// イミュータブル特性であり、プロパティを持たない
// しかし、プリミティブ型をオブジェクトに自動変換する（オートボクシング）ことがJSでは可能

0.1 === .1;
5.0 === 5.;

// 2進数(0bを先頭に付ける)
// 0b1010
// 8進数(0oを先頭に付ける)
// 0o755
// 16進数(0xを先頭に付ける)
// 0xfff

// 100_000_000 // 1億

// 5.toString(); この書き方は構文エラー
5..toString();
(5).toString();

// 数値にならない場合NaNとなる
// 値がNaNであるかのチェックは、Number.isNaNを使用
// 無限大はInfinityとなる

// 0.1 + 0.2 === 0.3; //=> false
// number型がIEEE754という規格に準拠しているため
// 110 * 1.1; //=> 121.00000000000001
// 上記の代わりに下記
// (110 * 11) / 10 === 121; //=> true
// この方法を使う場合は、桁を戻した数値は小数になることがあり、その値には小数計算誤差問題が残り続ける

// バックスラッシュでエスケープ可能

// javascriptのundefinedは未定義を表すプリミティブな値

// nullはプログラマーが意図的に使わない限り発生しない
// 基本的にはundefinedを使用するで問題ないが、ある程度nullを理解することも重要